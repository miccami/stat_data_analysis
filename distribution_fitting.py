# -*- coding: utf-8 -*-
"""ПЗМС_3_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kDGYATbJ0gBzGJ9G0wLWb11bD6wDkAAf

![image.png](data:image/png;base64,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)
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import stats
from sklearn.linear_model import LinearRegression

with open('1.txt', 'r') as file:
    data1 = file.readlines()


data1 = [float(x.strip()) for x in data1]

plt.figure(figsize=(8, 6))
plt.hist(data1, bins=30, density=True, alpha=0.5, color='skyblue', edgecolor='black')
plt.title('Гистограмма данных')
plt.xlabel('Значения')
plt.ylabel('Плотность')
plt.grid(True)
plt.show()

"""**Критерий пирсона**: ![image.png](data:image/png;base64,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)

"""

n_groups = int(np.ceil(1 + np.log2(len(data1))))  # Количество групп (интервалов)
h = (max(data1) - min(data1)) / n_groups  # Ширина интервала
Z = np.arange(min(data1), max(data1) + h, h)  # Границы интервалов
X = (Z[:-1] + Z[1:]) / 2  # Центры интервалов


table_hist = pd.DataFrame({'values': data1})
table_hist['groups'] = pd.cut(data1, bins=Z)  # Группировка по интервалам

# Расчет абсолютной и относительной частоты
table_hist_grouped = table_hist.groupby('groups').size().reset_index(name='abs_freq')
table_hist_grouped['rel_freq'] = table_hist_grouped['abs_freq'] / len(data1)
table_hist_grouped['low'] = Z[:-1]
table_hist_grouped['upp'] = Z[1:]
table_hist_grouped['med'] = X

print(table_hist_grouped)

#получаем несмещенные точечные оценки для мат ожидания и ско
mu_sample = sum(table_hist_grouped['med'] * table_hist_grouped['rel_freq'])
sd_sample = np.sqrt(sum((table_hist_grouped['med'] - mu_sample) ** 2 * table_hist_grouped['rel_freq']))
lambda_sample = 1 / mu_sample

print(f'Оценка математического ожидания: {mu_sample:.3f}')
print(f'Оценка стандартного отклонения: {sd_sample:.3f}')

"""**Идентификация методом Пирсона истинного распределения**"""

#Интегрирование функции плотности нормального распределения
def integrate_normal(low=-np.inf, high=np.inf, mean_param=0, sd_param=1):
    return stats.norm.cdf(high, loc=mean_param, scale=sd_param) - stats.norm.cdf(low, loc=mean_param, scale=sd_param)

#Вычисление статистики χ²
def chisq_test_norm(table_hist, mean_p, sd_p):
    N = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
        theor[i] = N * integrate_normal(low=table_hist['low'][i], high=table_hist['upp'][i], mean_param=mean_p, sd_param=sd_p)

    chisq_d = sum((prac - theor) ** 2 / theor)
    return chisq_d

#Расчет χ² статистики
chisq_test = chisq_test_norm(table_hist_grouped, mu_sample, sd_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-2-1)#число оцениваемых параметров для норм. распред-е = 2
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')

"""**Идентификация методом Пирсона ложного распределения**"""

#Интегрирование функции плотности показательного распределения
def integrate_exponential(low=0, high=np.inf, lambda_sample=1):
    return stats.expon.cdf(high, scale=1/lambda_sample) - stats.expon.cdf(low,  scale=1/lambda_sample)

#Вычисление статистики χ²
def chisq_test_exp(table_hist, lambda_sample):
    N = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
      theor[i] = N * integrate_exponential(low=table_hist['low'][i], high=table_hist['upp'][i],  lambda_sample=lambda_sample)
      if theor[i] == 0:
        theor[i] = 1e-10 #чтобы избежать inf
    chisq_d = sum((prac - theor) ** 2 / theor)
    return chisq_d

#Расчет χ² статистики
chisq_test = chisq_test_exp(table_hist_grouped, lambda_sample=lambda_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-1-1)
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Пример данных
# table_hist_grouped = pd.DataFrame({
#     'med': [0, 50, 100, 150, 200],
#     'rel_freq': [0.2, 0.15, 0.1, 0.05, 0.02]
# })
# mu_sample = 100  # Пример значения выборки

# Ваши данные здесь
# table_hist_grouped = ...
# mu_sample = ...

# Преобразование данных
x = (table_hist_grouped['med'] - mu_sample) ** 2
y = np.log(table_hist_grouped['rel_freq'])

# Линейная регрессия
model = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построение графика
plt.figure(figsize=(10, 5))
plt.scatter(x, y, color='red', label='Данные')
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("X(i)")
plt.ylabel("ln(π)")
plt.title("Гистограмма в спрямляющих координатах")
plt.legend()
plt.grid()
plt.show()

print("Значения углового коэффициента и свободного члена: ", slope, intercept)
print("Коэффициент детерминации: ", r_squared)

# Построение гистограммы относительных частот
plt.figure(figsize=(10, 5))
plt.plot(table_hist_grouped['med'], table_hist_grouped['rel_freq'], color='red', marker='o', markersize=5, linewidth=1.2)
plt.xlabel("X(i)")
plt.ylabel("π")
plt.title("Гистограмма относительных частот")
plt.grid()
plt.show()

x = table_hist_grouped['med']
y = np.log(table_hist_grouped['rel_freq'])

model = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построим гистограмму в спрямляющих координатах
plt.figure(figsize=(10, 5))
plt.plot(x, y, color='red', marker='o', markersize=5, linewidth=1.2)
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("X(i)")
plt.ylabel("ln(π)")
plt.title("Гистограмма в спрямляющих координатах")
plt.grid()
plt.show()

print("Значения уголового коэффициента и свободного члена: ", slope, intercept)
print("Коэффицент детерминации: ",r_squared)

with open('4.txt', 'r') as file:
    data1 = file.readlines()

# Преобразование строк в числа с удалением лишних символов, таких как перенос строки
data1 = [float(x.strip()) for x in data1]
plt.figure(figsize=(8, 6))
plt.hist(data1, bins=30, density=True, alpha=0.5, color='skyblue', edgecolor='black')
plt.title('Гистограмма данных')
plt.xlabel('Значения')
plt.ylabel('Плотность')
plt.grid(True)
plt.show()

n_groups = int(np.ceil(1 + np.log2(len(data1))))  # Количество групп (интервалов)
h = (max(data1) - min(data1)) / n_groups  # Ширина интервала
Z = np.arange(min(data1), max(data1) + h, h)  # Границы интервалов
X = (Z[:-1] + Z[1:]) / 2  # Центры интервалов


table_hist = pd.DataFrame({'values': data1})
table_hist['groups'] = pd.cut(data1, bins=Z, include_lowest = True)  # Группировка по интервалам

# Расчет абсолютной и относительной частоты
table_hist_grouped = table_hist.groupby('groups').size().reset_index(name='abs_freq')
table_hist_grouped['rel_freq'] = table_hist_grouped['abs_freq'] / len(data1)
table_hist_grouped['low'] = Z[:-1]
table_hist_grouped['upp'] = Z[1:]
table_hist_grouped['med'] = X

print(table_hist_grouped)

#получаем несмещенные точечные оценки для мат ожидания и ско
mu_sample = sum(table_hist_grouped['med'] * table_hist_grouped['rel_freq'])
sd_sample = np.sqrt(sum((table_hist_grouped['med'] - mu_sample) ** 2 * table_hist_grouped['rel_freq']))
lambda_sample = 1 / mu_sample

print(f'Оценка математического ожидания: {mu_sample:.3f}')
print(f'Оценка стандартного отклонения: {sd_sample:.3f}')

#Интегрирование функции плотности нормального распределения
def integrate_normal(low=-np.inf, high=np.inf, mean_param=0, sd_param=1):
    return stats.norm.cdf(high, loc=mean_param, scale=sd_param) - stats.norm.cdf(low, loc=mean_param, scale=sd_param)

#Вычисление статистики χ²
def chisq_test_norm(table_hist, mean_p, sd_p):
    N = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
        theor[i] = N * integrate_normal(low=table_hist['low'][i], high=table_hist['upp'][i], mean_param=mean_p, sd_param=sd_p)

    chisq_d = sum((prac - theor) ** 2 / theor)
    return chisq_d

#Расчет χ² статистики
chisq_test = chisq_test_norm(table_hist_grouped, mu_sample, sd_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-2-1)#число оцениваемых параметров для норм. распред-е = 2
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')

#Интегрирование функции плотности показательного распределения
def integrate_exponential(low=0, high=np.inf, lambda_sample=1):
    return stats.expon.cdf(high, scale=1/lambda_sample) - stats.expon.cdf(low,  scale=1/lambda_sample)

#Вычисление статистики χ²
def chisa_test_exp(table_hist, lambda_sample):
    M = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
        theor[i] = M * integrate_exponential(low=table_hist['low'][i], high=table_hist['upp'][i], lambda_sample=lambda_sample)
        if theor[i] == 0:
            theor[i] = 1e-10  # чтобы избежать inf
        print(f"Интервал [{table_hist['low'][i]}, {table_hist['upp'][i]}]: prac = {prac[i]}, theor = {theor[i]}")

    chisa_d = sum((prac - theor) ** 2 / theor)
    print(f"χ² статистика: {chisa_d}")
    return chisa_d


#Расчет χ² статистики
chisq_test = chisq_test_exp(table_hist_grouped, lambda_sample=lambda_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-1-1)
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')
print("Данные для проверки:")
print(table_hist_grouped)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Пример данных
# table_hist_grouped = pd.DataFrame({
#     'med': [0, 50, 100, 150, 200],
#     'rel_freq': [0.2, 0.15, 0.1, 0.05, 0.02]
# })
# mu_sample = 100  # Пример значения выборки

# Ваши данные здесь
# table_hist_grouped = ...
# mu_sample = ...

# Преобразование данных
x = (table_hist_grouped['med'] - mu_sample) ** 2
y = np.log(table_hist_grouped['rel_freq'])

# Линейная регрессия
model = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построение графика
plt.figure(figsize=(10, 5))
plt.scatter(x, y, color='red', label='Данные')
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("X(i)")
plt.ylabel("ln(π)")
plt.title("Гистограмма в спрямляющих координатах")
plt.legend()
plt.grid()
plt.show()

print("Значения углового коэффициента и свободного члена: ", slope, intercept)
print("Коэффициент детерминации: ", r_squared)

# Построение гистограммы относительных частот
plt.figure(figsize=(10, 5))
plt.plot(table_hist_grouped['med'], table_hist_grouped['rel_freq'], color='red', marker='o', markersize=5, linewidth=1.2)
plt.xlabel("X(i)")
plt.ylabel("π")
plt.title("Гистограмма относительных частот")
plt.grid()
plt.show()

x = table_hist_grouped['med']
y = np.log(table_hist_grouped['rel_freq'])

model = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построим гистограмму в спрямляющих координатах
plt.figure(figsize=(10, 5))
plt.plot(x, y, color='red', marker='o', markersize=5, linewidth=1.2)
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("X(i)")
plt.ylabel("ln(π)")
plt.title("Гистограмма в спрямляющих координатах")
plt.grid()
plt.show()

print("Значения уголового коэффициента и свободного члена: ", slope, intercept)
print("Коэффицент детерминации: ",r_squared)

with open('3.txt', 'r') as file:
    data1 = file.readlines()

# Преобразование строк в числа с удалением лишних символов, таких как перенос строки
data1 = [float(x.strip()) for x in data1]

plt.figure(figsize=(8, 6))
plt.hist(data1, bins=30, density=True, alpha=0.5, color='skyblue', edgecolor='black')
plt.title('Гистограмма данных')
plt.xlabel('Значения')
plt.ylabel('Плотность')
plt.grid(True)
plt.show()

n_groups = int(np.ceil(1 + np.log2(len(data1))))  # Количество групп (интервалов)
h = (max(data1) - min(data1)) / n_groups  # Ширина интервала
Z = np.arange(min(data1), max(data1) + h, h)  # Границы интервалов
X = (Z[:-1] + Z[1:]) / 2  # Центры интервалов


table_hist = pd.DataFrame({'values': data1})
table_hist['groups'] = pd.cut(data1, bins=Z, include_lowest = True)  # Группировка по интервалам

# Расчет абсолютной и относительной частоты
table_hist_grouped = table_hist.groupby('groups').size().reset_index(name='abs_freq')
table_hist_grouped['rel_freq'] = table_hist_grouped['abs_freq'] / len(data1)
table_hist_grouped['low'] = Z[:-1]
table_hist_grouped['upp'] = Z[1:]
table_hist_grouped['med'] = X

print(table_hist_grouped)

#получаем несмещенные точечные оценки для мат ожидания и ско
mu_sample = sum(table_hist_grouped['med'] * table_hist_grouped['rel_freq'])
sd_sample = np.sqrt(sum((table_hist_grouped['med'] - mu_sample) ** 2 * table_hist_grouped['rel_freq']))
lambda_sample = 1 / mu_sample

print(f'Оценка математического ожидания: {mu_sample:.3f}')
print(f'Оценка стандартного отклонения: {sd_sample:.3f}')

#Интегрирование функции плотности нормального распределения
def integrate_normal(low=-np.inf, high=np.inf, mean_param=0, sd_param=1):
    return stats.norm.cdf(high, loc=mean_param, scale=sd_param) - stats.norm.cdf(low, loc=mean_param, scale=sd_param)

#Вычисление статистики χ²
def chisq_test_norm(table_hist, mean_p, sd_p):
    N = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
        theor[i] = N * integrate_normal(low=table_hist['low'][i], high=table_hist['upp'][i], mean_param=mean_p, sd_param=sd_p)

    chisq_d = sum((prac - theor) ** 2 / theor)
    return chisq_d

#Расчет χ² статистики
chisq_test = chisq_test_norm(table_hist_grouped, mu_sample, sd_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-2-1)#число оцениваемых параметров для норм. распред-е = 2
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')

#Интегрирование функции плотности показательного распределения
def integrate_exponential(low=0, high=np.inf, lambda_sample=1):
    return stats.expon.cdf(high, scale=1/lambda_sample) - stats.expon.cdf(low,  scale=1/lambda_sample)

#Вычисление статистики χ²
def chisq_test_exp(table_hist, lambda_sample):
    N = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
      theor[i] = N * integrate_exponential(low=table_hist['low'][i], high=table_hist['upp'][i],  lambda_sample=lambda_sample)
      if theor[i] == 0:
        theor[i] = 1e-10#чтобы избежать inf

    chisq_d = sum((prac - theor) ** 2 / theor)
    return chisq_d

#Расчет χ² статистики
chisq_test = chisq_test_exp(table_hist_grouped, lambda_sample=lambda_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-1-1)
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')

# Построение гистограммы относительных частот
plt.figure(figsize=(10, 5))
plt.plot(table_hist_grouped['med'], table_hist_grouped['rel_freq'], color='red', marker='o', markersize=5, linewidth=1.2)
plt.xlabel("X(i)")
plt.ylabel("π")
plt.title("Гистограмма относительных частот")
plt.grid()
plt.show()

x = (table_hist_grouped['med'] - mu_sample) ** 2
y = np.log(table_hist_grouped['rel_freq'])

mode2 = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построим гистограмму в спрямляющих координатах
plt.figure(figsize=(10, 5))
plt.plot(x,y, color='red', marker='o', markersize=5, linewidth=1.2)
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("X(i)")
plt.ylabel("ln(π)")
plt.title("Гистограмма в спрямляющих координатах")
plt.grid()
plt.show()

print("Значения уголового коэффициента и свободного члена: ", slope, intercept)
print("Коэффицент детерминации: ",r_squared)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Пример данных
# table_hist_grouped = pd.DataFrame({
#     'med': [0, 5, 10, 15, 20],
#     'rel_freq': [0.2, 0.15, 0.1, 0.05, 0.02]
# })
# Ваши данные здесь
# table_hist_grouped = ...

# Преобразование данных
x = table_hist_grouped['med']
y = np.log(table_hist_grouped['rel_freq'])

# Линейная регрессия
model = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построение графика
plt.figure(figsize=(10, 5))
plt.scatter(x, y, color='red', label='Исходные данные')
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("Квадрат отклонения X(i) от выборочного среднего")
plt.ylabel("ln(π) [логарифм относительной частоты]")
plt.title("Гистограмма в спрямляющих координатах")
plt.legend()
plt.grid()
plt.show()

print("Угловой коэффициент (slope):", slope)
print("Свободный член (intercept):", intercept)
print("Коэффициент детерминации (R²):", r_squared)

with open('6.txt', 'r') as file:
    data1 = file.readlines()

# Преобразование строк в числа с удалением лишних символов, таких как перенос строки
data1 = [float(x.strip()) for x in data1]

plt.figure(figsize=(8, 6))
plt.hist(data1, bins=30, density=True, alpha=0.5, color='skyblue', edgecolor='black')
plt.title('Гистограмма данных')
plt.xlabel('Значения')
plt.ylabel('Плотность')
plt.grid(True)
plt.show()

n_groups = int(np.ceil(1 + np.log2(len(data1))))  # Количество групп (интервалов)
h = (max(data1) - min(data1)) / n_groups  # Ширина интервала
Z = np.arange(min(data1), max(data1) + h, h)[:-1]  # Границы интервалов
X = (Z[:-1] + Z[1:]) / 2  # Центры интервалов


table_hist = pd.DataFrame({'values': data1})
table_hist['groups'] = pd.cut(data1, bins=Z, include_lowest = True,right = True)  # Группировка по интервалам

# Расчет абсолютной и относительной частоты
table_hist_grouped = table_hist.groupby('groups').size().reset_index(name='abs_freq')
table_hist_grouped['rel_freq'] = table_hist_grouped['abs_freq'] / len(data1)
table_hist_grouped['low'] = Z[:-1]
table_hist_grouped['upp'] = Z[1:]
table_hist_grouped['med'] = X

print(table_hist_grouped)

#получаем несмещенные точечные оценки для мат ожидания и ско
mu_sample = sum(table_hist_grouped['med'] * table_hist_grouped['rel_freq'])
sd_sample = np.sqrt(sum((table_hist_grouped['med'] - mu_sample) ** 2 * table_hist_grouped['rel_freq']))
lambda_sample = 1 / mu_sample

print(f'Оценка математического ожидания: {mu_sample:.3f}')
print(f'Оценка стандартного отклонения: {sd_sample:.3f}')

#Интегрирование функции плотности нормального распределения
def integrate_normal(low=-np.inf, high=np.inf, mean_param=0, sd_param=1):
    return stats.norm.cdf(high, loc=mean_param, scale=sd_param) - stats.norm.cdf(low, loc=mean_param, scale=sd_param)

#Вычисление статистики χ²
def chisq_test_norm(table_hist, mean_p, sd_p):
    N = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
        theor[i] = N * integrate_normal(low=table_hist['low'][i], high=table_hist['upp'][i], mean_param=mean_p, sd_param=sd_p)

    chisq_d = sum((prac - theor) ** 2 / theor)
    return chisq_d

#Расчет χ² статистики
chisq_test = chisq_test_norm(table_hist_grouped, mu_sample, sd_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-2-1)#число оцениваемых параметров для норм. распред-е = 2
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')

#Интегрирование функции плотности показательного распределения
def integrate_exponential(low=0, high=np.inf, lambda_sample=1):
    return stats.expon.cdf(high, scale=1/lambda_sample) - stats.expon.cdf(low,  scale=1/lambda_sample)

#Вычисление статистики χ²
def chisq_test_exp(table_hist, lambda_sample):
    N = sum(table_hist['abs_freq'])
    prac = table_hist['abs_freq'].values
    theor = np.zeros(len(table_hist))

    for i in range(len(table_hist)):
      theor[i] = N * integrate_exponential(low=table_hist['low'][i], high=table_hist['upp'][i],  lambda_sample=lambda_sample)
      if theor[i] == 0:
        theor[i] = 1e-10#чтобы избежать inf

    chisq_d = sum((prac - theor) ** 2 / theor)
    return chisq_d

#Расчет χ² статистики
chisq_test = chisq_test_exp(table_hist_grouped, lambda_sample)

#Сравнение с критическим значением χ²
critical_value = stats.chi2.ppf(0.95, df=n_groups-1-1)
print(f'χ² статистика: {chisq_test:.3f}')
print(f'Критическое значение χ²: {critical_value:.3f}')
print(f'Результат теста: {"Принять гипотезу" if chisq_test < critical_value else "Отвергнуть гипотезу"}')

# Построение гистограммы относительных частот
plt.figure(figsize=(10, 5))
plt.plot(table_hist_grouped['med'], table_hist_grouped['rel_freq'], color='red', marker='o', markersize=5, linewidth=1.2)
plt.xlabel("X(i)")
plt.ylabel("π")
plt.title("Гистограмма относительных частот")
plt.grid()
plt.show()

x = (table_hist_grouped['med'] - mu_sample) ** 2
y = np.log(table_hist_grouped['rel_freq'])

mode2 = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построим гистограмму в спрямляющих координатах
plt.figure(figsize=(10, 5))
plt.plot(x,y, color='red', marker='o', markersize=5, linewidth=1.2)
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("X(i)")
plt.ylabel("ln(π)")
plt.title("Гистограмма в спрямляющих координатах")
plt.grid()
plt.show()

print("Значения уголового коэффициента и свободного члена: ", slope, intercept)
print("Коэффицент детерминации: ",r_squared)

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Пример данных
# table_hist_grouped = pd.DataFrame({
#     'med': [0, 5, 10, 15, 20],
#     'rel_freq': [0.2, 0.15, 0.1, 0.05, 0.02]
# })
# Ваши данные здесь
# table_hist_grouped = ...

# Преобразование данных
x = table_hist_grouped['med']
y = np.log(table_hist_grouped['rel_freq'])

# Линейная регрессия
model = LinearRegression()
x = x.values.reshape(-1, 1)  # Преобразуем в 2D массив
model.fit(x, y)

# Получаем угловой коэффициент и свободный член
slope = model.coef_[0]
intercept = model.intercept_

y_pred = model.predict(x)

r_squared = model.score(x, y)

# Построение графика
plt.figure(figsize=(10, 5))
plt.scatter(x, y, color='red', label='Исходные данные')
plt.plot(x, y_pred, color='blue', linewidth=2, label='Линейная регрессия')
plt.xlabel("Квадрат отклонения X(i) от выборочного среднего")
plt.ylabel("ln(π) [логарифм относительной частоты]")
plt.title("Гистограмма в спрямляющих координатах")
plt.legend()
plt.grid()
plt.show()

print("Угловой коэффициент (slope):", slope)
print("Свободный член (intercept):", intercept)
print("Коэффициент детерминации (R²):", r_squared)